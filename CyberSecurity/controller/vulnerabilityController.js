const path = require("path")
const { exec } = require('child_process');
const fs = require('fs');
const archiver = require('archiver');
const { v4: uuidv4 } = require('uuid');
const convertMultipleTextToPDF = require("./multipleTxtFileConvertion")
//this function for get the path of userFolders
function getPathUserFolders() {
    const uniqueId = uuidv4()
    let folderPath = path.resolve(__dirname, '..');
    folderPath = path.join(folderPath, "userFolders", uniqueId)


    return folderPath
}
// create folder 
async function createFolder(location) {
    try {
        await fs.promises.mkdir(location, { recursive: true });
        console.log('Folder created successfully');
    } catch (err) {
        console.error(`Failed to create folder: ${err.message}`);
    }
}
// this get the path for specific bash file it take like vulnerability/nse.sh
function getPathBash(subFilePath) {
    let bashPath = path.resolve(__dirname, '..');
    bashPath = path.join(bashPath, `bashs/${subFilePath}`)
    return bashPath
}
function addFiles(inputFiles, titles, file, title) {
    if (fs.existsSync(file)) {
        inputFiles.push(file)
        titles.push(title)
    }
}
// it execute the bash for vulnerability
async function executeBash(command, location, nameOfFile, inputFiles, titles) {
    return new Promise((resolve, reject) => {
        exec(command, async (error, stdout, stderr) => {
            if (error) {
                console.error(`Error executing ${nameOfFile} scan:`, error);
                return reject(error); // Reject if there's an error
            }

            if (stderr) {
                console.warn(`Warning from ${nameOfFile} scan:`, stderr);
            }

            console.log(`${nameOfFile} scan completed successfully.`);

            // Define the path of the expected output file
            const txtFilePath = `${location}/${nameOfFile}.txt`;
            addFiles(inputFiles, titles, txtFilePath, nameOfFile)
            resolve()
        })
    })

}
function convertFilesToPDF(inputFiles, titles, location, callback) {

    const title = "Brute-Horse Result"
    const outputFile = `${location}/output.pdf`;

    convertMultipleTextToPDF(inputFiles, outputFile, titles, title, (err) => {
        if (err) {
            console.error('Failed to convert text files to PDF:', err);
        } else {
            console.log('PDF conversion completed successfully!');
            callback(null)
        }
    });
}
async function scanVulnerability(nameOfTool, ip, location, inputFiles, titles) {
    let nameOfBashFile = ""
    if (nameOfTool === 'wapiti')
        nameOfBashFile = "vulnerability/scan.sh"
    else if(nameOfTool==="nse") 
        nameOfBashFile = "vulnerability/nse.sh"
    const bashPath = getPathBash(nameOfBashFile)
    const command = `bash ${bashPath} ${ip} ${location}`
    await executeBash(command, location, nameOfTool, inputFiles, titles)
}
const scanPorts = async (ip,location,inputFiles,titles,scanSpeed,scanType,verbosity,startPort=1,endPort=1000) => {
    const bashPath = getPathBash("portScanning/scan.sh")
    //"Usage: $0 <IP_ADDRESS> [TIME_SPEED] [OUTPUT_DIR] [SCAN_TYPE] [START_PORT] [END_PORT]"
    const command = `sudo bash ${bashPath} ${ip} ${scanSpeed} ${location} ${scanType} ${startPort} ${endPort} ${verbosity===1 ? "-v":""}`
    await executeBash(command,location,"portScanning",inputFiles,titles)
}
const sqliScan = async (url ,location,inputFiles,titles,database,column,table,params) => {
    const bashPath = getPathBash("Sqli/sqli.sh")
    const command = `bash ${bashPath} -u ${url} ${location} ${database==="" ? "":`-D ${database}`} ${column==="" ? "":`-C ${column}`} ${table==="" ? "":`-T ${table}`} ${params==="" ? "":`-p ${params}`}`
    await executeBash(command,location,"sqli",inputFiles,titles)
}
async function totalProcess(req, res) {
    const location = getPathUserFolders()
    const inputFiles = []
    const titles = []
    const ip = req.body.ip
    req.body.id = uuidv4();
    const scanType = req.body.scanType
    const scanSpeed = req.body.scanSpeed
    const startPort = req.body.startPort || 1
    const endPort = req.body.endPort || 1000
    const verbosity = Number(req.body.verbosity)
    const url = req.body.url || `http:${ip}/`
    const database = req.body.database || ""
    const column = req.body.column || ""
    const table = req.body.table || ""
    const params = req.body.params || ""
    await createFolder(location)
    await scanPorts(ip,location,inputFiles,titles,scanSpeed,scanType,verbosity,startPort,endPort)
    await scanVulnerability("wapiti", ip, location, inputFiles, titles)  
    await scanVulnerability("nse", ip, location, inputFiles, titles)
    await sqliScan(url,location,inputFiles,titles,database,column,table,params)
    convertFilesToPDF(inputFiles, titles, location, (err) => {
        if (err) {
            console.error('Failed to convert text files to PDF:', err);
        } else {
            downloadFolder(req, res, location)
        }
    })


}
function downloadFolder(req, res, location) {
    if (!fs.existsSync(location)) {
        return res.status(404).send({ message: 'Folder not found' });
    }

    const zipFileName = `report.zip`;
    res.setHeader('Content-Disposition', `attachment; filename=${zipFileName}`);
    res.setHeader('Content-Type', 'application/zip');

    const archive = archiver('zip', { zlib: { level: 9 } });

    archive.on('error', (err) => {
        return res.status(500).send({ message: err.message });
    });

    archive.pipe(res);
    archive.directory(location, false);
    archive.finalize();

    // Once the response is finished, delete the folder
    res.on('finish', () => {
        fs.rmdirSync(location, { recursive: true });
    });
}
function removeFolderWithoutDownload(req, res, location) {


    if (!fs.existsSync(location)) {
        return res.status(404).send({ message: 'Folder not found' });
    }
    fs.rmdirSync(location, { recursive: true });

    res.status(200).json({ message: "The folder is deleted without download it" })
}
module.exports = totalProcess
