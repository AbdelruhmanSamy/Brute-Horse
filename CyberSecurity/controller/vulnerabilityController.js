const path = require("path")
const { exec } = require('child_process');
const fs = require('fs');
const archiver = require('archiver');
const convertTextToPDF = require("./textToPDF")
//this function for get the path of userFolders
function getPathUserFolders(uniqueId) {
    let folderPath = path.resolve(__dirname, '..');
    folderPath = path.join(folderPath, "userFolders", uniqueId)
    return folderPath
}
// this get the path for specific bash file it take like vulnerability/nse.sh
function getPathBash(subFilePath) {
    let bashPath = path.resolve(__dirname, '..');
    bashPath = path.join(bashPath, `bashs/${subFilePath}`)
    return bashPath
}
// it delete the file.txt after move it into pdf 
function removeFile(filePath) {
    try {
        fs.unlinkSync(filePath);
        console.log('File deleted successfully');
    } catch (err) {
        console.error('Error while deleting the file:', err);
    }
}
// convert txt file to pdf
function convertWapitiTxtTOPDF(location,nameSubFile) {
    if (fs.existsSync(location + `/${nameSubFile}.txt`)) {
        convertTextToPDF(location + `/${nameSubFile}.txt`, location + `/${nameSubFile}.pdf`, `${nameSubFile} Results`)
        removeFile(location + `/${nameSubFile}.txt`)
    }
}
// it execute the bash for vulnerability
function executeBash(scriptPath, ip, location,nameSubFile, callback) {
    exec(`bash ${scriptPath} ${ip} ${location}`, (error, stdout, stderr) => {
        if (error || stderr) {
            callback(false);  // Return false through the callback if there's an error
        } else {
            console.log("ok");
            convertWapitiTxtTOPDF(location,nameSubFile)
            callback(true);   // Return true if everything is fine
        }
    });
}

function scanVulnerabilityWithWapiti(req, res) {
    const ip = req.body.ip
    const uniqueId = req.body.uniqueId;
    const pathBash = getPathBash("vulnerability/scan.sh")
    const location = getPathUserFolders(uniqueId)
    executeBash(pathBash, ip, location,"wapiti", (result) => {
        if (result) {
            console.log('Success');
        } else {
            console.log('Failed');
        }
    })


}
function scanVulnerabilityWithNSE(req, res) {
    const ip = req.body.ip
    const uniqueId = req.body.uniqueId;
    const pathBash = getPathBash("vulnerability/nse.sh")
    const location = getPathUserFolders(uniqueId)
    console.log(location)
    executeBash(pathBash, ip, location,"nse", (result) => {
        if (result) {
            console.log('Success');
        } else {
            console.log('Failed');
        }
    })


}
function downloadFolder(req, res) {
    const uniqueId = req.body.id;
    const location = getPathUserFolders(uniqueId)

    if (!fs.existsSync(location)) {
        return res.status(404).send({ message: 'Folder not found' });
    }

    const zipFileName = `report-${uniqueId}.zip`;
    res.setHeader('Content-Disposition', `attachment; filename=${zipFileName}`);
    res.setHeader('Content-Type', 'application/zip');

    const archive = archiver('zip', { zlib: { level: 9 } });

    archive.on('error', (err) => {
        return res.status(500).send({ message: err.message });
    });

    archive.pipe(res);
    archive.directory(location, false);
    archive.finalize();

    // Once the response is finished, delete the folder
    res.on('finish', () => {
        fs.rmdirSync(location, { recursive: true });
    });
}
function removeFolderWithoutDownload(req, res) {
    const uniqueId = req.body.id;
    const location = getPathUserFolders(uniqueId)

    if (!fs.existsSync(location)) {
        return res.status(404).send({ message: 'Folder not found' });
    }
    fs.rmdirSync(location, { recursive: true });
    res.status(200).json({ message: "The folder is deleted without download it" })
}
module.exports = { scanVulnerabilityWithWapiti, downloadFolder, removeFolderWithoutDownload,scanVulnerabilityWithNSE }
