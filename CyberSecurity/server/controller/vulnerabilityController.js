const path = require("path")
const { exec } = require('child_process');
const fs = require('fs');
const archiver = require('archiver');
const { v4: uuidv4 } = require('uuid');
const convertMultipleTextToPDF = require("./multipleTxtFileConvertion")
//this function for get the path of userFolders
function getPathUserFolders() {
    const uniqueId = uuidv4()
    let folderPath = path.resolve(__dirname, '..');
    folderPath = path.join(folderPath, "userFolders", uniqueId)


    return folderPath
}
// create folder 
async function createFolder(location) {
    try {
        await fs.promises.mkdir(location, { recursive: true });
        console.log('Folder created successfully');
    } catch (err) {
        console.error(`Failed to create folder: ${err.message}`);
    }
}
// this get the path for specific bash file it take like vulnerability/nse.sh
function getPathBash(subFilePath) {
    let bashPath = path.resolve(__dirname, '..');
    bashPath = path.join(bashPath, `../bashs/${subFilePath}`)
    return bashPath
}
function addFiles(inputFiles, titles, file, title) {
    if (fs.existsSync(file)) {
        inputFiles.push(file)
        titles.push(title)
    }
}
// it execute the bash for vulnerability
async function executeBash(command, location, nameOfFile, inputFiles, titles) {
    return new Promise((resolve, reject) => {
        exec(command, async (error, stdout, stderr) => {
            if (error) {
                console.error(`Error executing ${nameOfFile} scan:`, error);
                return reject(error); // Reject if there's an error
            }

            if (stderr) {
                console.warn(`Warning from ${nameOfFile} scan:`, stderr);
            }

            console.log(`${nameOfFile} scan completed successfully.`);

            // Define the path of the expected output file
            const txtFilePath = `${location}/${nameOfFile}.txt`;
            addFiles(inputFiles, titles, txtFilePath, nameOfFile)
            resolve()
        })
    })

}
function convertFilesToPDF(inputFiles, titles, location, callback) {

    const title = "Brute-Horse Result"
    const outputFile = `${location}/output.pdf`;

    convertMultipleTextToPDF(inputFiles, outputFile, titles, title, (err) => {
        if (err) {
            console.error('Failed to convert text files to PDF:', err);
        } else {
            console.log('PDF conversion completed successfully!');
            callback(null)
        }
    });
}
async function scanVulnerability(nameOfTool, ip, location, inputFiles, titles) {
    let nameOfBashFile = ""
    if (nameOfTool === 'wapiti')
        nameOfBashFile = "vulnerability/scan.sh"
    else if(nameOfTool==="nse") 
        nameOfBashFile = "vulnerability/nse.sh"
    const bashPath = getPathBash(nameOfBashFile)
    const command = `bash ${bashPath} ${ip} ${location}`
    await executeBash(command, location, nameOfTool, inputFiles, titles)
}
async function scanServers(nameOfTool, ip, location,choice,userName, inputFiles, titles) {
    if(!userName)
    userName=""
    console.log(userName)
    let nameOfBashFile = ""
    if (nameOfTool === 'ftp')
        nameOfBashFile = '"Anonymous FTP"/ftp.sh'
    else nameOfBashFile = '"Anonymous SMB"/smb.sh'
    const bashPath = getPathBash(nameOfBashFile)
    const command = `bash ${bashPath} ${ip} ${choice} ${location} ${userName}`
    await executeBash(command, location, nameOfTool, inputFiles, titles)
}
const scanPorts = async (ip,location,inputFiles,titles,scanSpeed,scanType,verbosity,startPort=1,endPort=1000) => {
    const bashPath = getPathBash("portScanning/scan.sh")
    //"Usage: $0 <IP_ADDRESS> [TIME_SPEED] [OUTPUT_DIR] [SCAN_TYPE] [START_PORT] [END_PORT]"
    const command = `sudo bash ${bashPath} ${ip} ${scanSpeed} ${location} ${scanType} ${startPort} ${endPort} ${verbosity===1 ? "-v":""}`
    await executeBash(command,location,"portScanning",inputFiles,titles)
}
const sqliScan = async (url ,location,inputFiles,titles,database,column,table,params) => {
    const bashPath = getPathBash("Sqli/sqli.sh")
    const command = `bash ${bashPath} -u ${url} ${location} ${database==="" ? "":`-D ${database}`} ${column==="" ? "":`-C ${column}`} ${table==="" ? "":`-T ${table}`} ${params==="" ? "":`-p ${params}`}`
    await executeBash(command,location,"sqli",inputFiles,titles)
}

/**
 * 0 -> imple. -1 -> need to be edited , 1 -> not imple , 2 -> need to be edited at frontend
 * {column: undefined 0,
​database: undefined​ 0,
endPort: undefined​ 0,
ftpChoice: "Anonymous login" 0,
​ftpSection: true​ 1 ,
ftpUsername: undefined 0,
​ip: "10.10.167.97" 0,
​nmapScanType: "-PS" 2,
​nmapSection: true 1,
​param: undefined 0,
​portScanType: "Both" -1,
​portScanning: true​ 1,
rangeScan: false​ 1 ,
scanSpeed: "4"​ 0,
smbChoice: "Anonymous login"​ -1 ,
smbSection: true​ 1,
smbUsername: undefined 0,
​sqli: true​ 1,
startPort: undefined 0​,
table: undefined​ 0 ,
url: "https://0a77005603df9ba880f53a220072006c.web-security-academy.net/filter?category=Corporate+gifts" 0,​ 
verbosity: true 0
} */
const convertChoiceToNumber =(choice)=>{
    choice = choice || "Anonymous login";
    let res = (choice==="Anonymous login") ? 1 : (choice==="Password breaking only") ? 2 : 3;  
    return res;
}

async function totalProcess(req,res) {
    const location = getPathUserFolders()
    const inputFiles = []
    const titles = []
    const ip = req.body.ip
    req.body.id = uuidv4();
    const scanType = req.body.nmapScanType
    const scanSpeed = req.body.scanSpeed
    const startPort = req.body.startPort || 1
    const endPort = req.body.endPort || 1000
    const verbosity = Number(req.body.verbosity)
    const url = req.body.url || `http:${ip}/`
    const database = req.body.database || ""
    const column = req.body.column || ""
    const table = req.body.table || ""
    const params = req.body.params || ""
    const ftpChoice = convertChoiceToNumber(req.body.ftpChoice)
    const smbChoice = convertChoiceToNumber(req.body.smbChoice)
    const ftpUserName = req.body.ftpUserName || ""
    const smbUserName = req.body.smbUserName || ""
    const wapitiStart = (req.body.portScanType==="Both" || req.body.portScanType==="wapiti") ? true:false;
    const nseStart = (req.body.portScanType==="Both" || req.body.portScanType==="nse") ? true:false;
    await createFolder(location)
    if(req.body.nmapSection===true)
        await scanPorts(ip,location,inputFiles,titles,scanSpeed,scanType,verbosity,startPort,endPort)
    if(wapitiStart===true)
        await scanVulnerability("wapiti", ip, location, inputFiles, titles)  
    if(nseStart===true)
        await scanVulnerability("nse", ip, location, inputFiles, titles)
    if(req.body.sqli===true)
        await sqliScan(url,location,inputFiles,titles,database,column,table,params)
    if(req.body.ftpSection===true)
        await scanServers("ftp", ip, location,ftpChoice,ftpUserName, inputFiles, titles)
    if(req.body.smbSection===true)
        await scanServers("smb", ip, location,smbChoice,smbUserName, inputFiles, titles)
    convertFilesToPDF(inputFiles, titles, location, (err) => {
        if (err) {
            console.error('Failed to convert text files to PDF:', err);
        } else {
            downloadFolder(req, res, location)
        }
    })


}
function downloadFolder(req, res, location) {
    if (!fs.existsSync(location)) {
        return res.status(404).send({ message: 'Folder not found' });
    }

    const zipFileName = `report.zip`;
    res.setHeader('Content-Disposition', `attachment; filename=${zipFileName}`);
    res.setHeader('Content-Type', 'application/zip');

    const archive = archiver('zip', { zlib: { level: 9 } });

    archive.on('error', (err) => {
        return res.status(500).send({ message: err.message });
    });

    archive.pipe(res);
    archive.directory(location, false);
    archive.finalize();

    // Once the response is finished, delete the folder
    res.on('finish', () => {
        fs.rmdirSync(location, { recursive: true });
    });
}
function removeFolderWithoutDownload(req, res, location) {


    if (!fs.existsSync(location)) {
        return res.status(404).send({ message: 'Folder not found' });
    }
    fs.rmdirSync(location, { recursive: true });

    res.status(200).json({ message: "The folder is deleted without download it" })
}
module.exports = totalProcess



